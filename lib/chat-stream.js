/**
 * Chat Stream Service
 *
 * Provides JSONL log streaming for Life Chat app.
 * Transforms Claude Code JSONL entries into SSE events using message lifecycle pattern.
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const readline = require('readline');
const chokidar = require('chokidar');

// ============================================================================
// Constants
// ============================================================================

const CLAUDE_PROJECTS_DIR = path.join(os.homedir(), '.claude', 'projects');
const CLAUDE_GATEWAY_DIR = path.join(os.homedir(), '.claude-gateway');
const INTERACTIVE_SESSIONS_DIR = path.join(CLAUDE_GATEWAY_DIR, 'interactive-sessions');
const HEARTBEAT_INTERVAL_MS = 30000;
const TAILER_IDLE_TIMEOUT_MS = 60000; // Clean up tailer after 60s with no clients

// Entry types to skip (internal bookkeeping)
const SKIP_ENTRY_TYPES = new Set(['file-history-snapshot', 'queue-operation']);

function ensureInteractiveSessionsDir() {
  try {
    fs.mkdirSync(INTERACTIVE_SESSIONS_DIR, { recursive: true });
  } catch {
    // Ignore
  }
}

function isInteractiveSession(sessionId) {
  ensureInteractiveSessionsDir();
  return fs.existsSync(path.join(INTERACTIVE_SESSIONS_DIR, sessionId));
}

function markInteractiveSession(sessionId) {
  ensureInteractiveSessionsDir();
  try {
    fs.closeSync(fs.openSync(path.join(INTERACTIVE_SESSIONS_DIR, sessionId), 'a'));
  } catch {
    // Ignore
  }
}

function sanitizeAssistantText(text) {
  if (typeof text !== 'string' || text.trim().length === 0) return text;

  let cleaned = text;

  // Claude Code sometimes injects XML-like wrappers for local command metadata/output.
  // These are not user-facing content in Claude Chat, so hide them.
  const tagPatterns = [
    /<command-name>[\s\S]*?<\/command-name>/g,
    /<command-message>[\s\S]*?<\/command-message>/g,
    /<command-args>[\s\S]*?<\/command-args>/g,
    /<local-command-stdout>[\s\S]*?<\/local-command-stdout>/g,
    /<local-command-stderr>[\s\S]*?<\/local-command-stderr>/g,
  ];
  for (const re of tagPatterns) {
    cleaned = cleaned.replace(re, '');
  }

  // Remove the safety caveat that often follows these tags.
  cleaned = cleaned.replace(
    /Caveat:\s*The messages below were generated by the user running local commands\.[\s\S]*?(?:\n|$)/gi,
    ''
  );

  // Collapse excessive whitespace left behind by removals.
  cleaned = cleaned
    .replace(/\n{3,}/g, '\n\n')
    .trim();

  return cleaned;
}

// ============================================================================
// Session Discovery
// ============================================================================

/**
 * Convert project slug back to path
 * e.g., "-Users-jmwillis-code-life-mcp" -> "/Users/jmwillis/code/life-mcp"
 */
function slugToPath(slug) {
  return slug.replace(/^-/, '/').replace(/-/g, '/');
}

/**
 * Extract display name from project slug
 * e.g., "-Users-jmwillis-code-life-mcp" -> "life-mcp"
 */
function slugToDisplayName(slug) {
  const parts = slug.split('-').filter(Boolean);
  return parts[parts.length - 1] || slug;
}

/**
 * Discover all sessions from ~/.claude/projects/
 * Returns paginated sessions sorted by last modified (newest first)
 */
async function discoverSessions(options = {}) {
  const {
    limit = 50,
    offset = 0,
    state,
    project,
  } = options;

  if (!fs.existsSync(CLAUDE_PROJECTS_DIR)) {
    return { sessions: [], total: 0, hasMore: false };
  }

  const projectDirs = fs.readdirSync(CLAUDE_PROJECTS_DIR, { withFileTypes: true })
    .filter(d => d.isDirectory());

  const fileIndex = [];
  let total = 0;

  for (const projectDir of projectDirs) {
    const displayName = slugToDisplayName(projectDir.name);
    if (project && project !== displayName) {
      continue;
    }

    const projectPath = path.join(CLAUDE_PROJECTS_DIR, projectDir.name);
    const jsonlFiles = fs.readdirSync(projectPath)
      .filter(f => f.endsWith('.jsonl') && !f.startsWith('agent-'));

    for (const jsonlFile of jsonlFiles) {
      const jsonlPath = path.join(projectPath, jsonlFile);
      const sessionId = path.basename(jsonlFile, '.jsonl');

      try {
        const stat = fs.statSync(jsonlPath);
        total++;
        fileIndex.push({
          sessionId,
          project: displayName,
          displayName,
          jsonlPath,
          stat,
        });
      } catch {
        // Ignore unreadable files
      }
    }
  }

  // Sort by last modified (newest first)
  fileIndex.sort((a, b) => b.stat.mtimeMs - a.stat.mtimeMs);

  const start = Number(offset) || 0;
  const pageSize = Number(limit) || 50;
  const page = fileIndex.slice(start, start + pageSize);

  const sessions = [];
  for (const item of page) {
    try {
      const meta = await extractSessionMetaFast(item.jsonlPath, item.stat.size);

      const session = {
        id: item.sessionId,
        project: item.project,
        displayName: item.displayName,
        cwd: meta.cwd || `/unknown/${item.displayName}`,
        jsonlPath: item.jsonlPath,
        state: isInteractiveSession(item.sessionId) ? 'interactive' : 'read_only',
        isActive: false,
        createdAt: meta.createdAt || item.stat.birthtime.toISOString(),
        lastMessageAt: meta.lastMessageAt || item.stat.mtime.toISOString(),
        lastMessagePreview: meta.lastMessagePreview || '',
        messageCount: meta.messageCount || 0,
        fileSize: item.stat.size,
      };

      if (state && session.state !== state) {
        continue;
      }

      sessions.push(session);
    } catch {
      // Skip malformed/unreadable session
    }
  }

  const hasMore = start + sessions.length < total;
  return { sessions, total, hasMore };
}

/**
 * Extract metadata from JSONL file (first and last entries)
 * Uses efficient streaming to handle large files
 */
async function extractSessionMetaFast(jsonlPath, fileSize) {
  const meta = {
    cwd: null,
    createdAt: null,
    lastMessageAt: null,
    lastMessagePreview: '',
    messageCount: 0,
  };

  try {
    const fd = fs.openSync(jsonlPath, 'r');
    try {
      const firstChunk = Buffer.alloc(32 * 1024);
      fs.readSync(fd, firstChunk, 0, firstChunk.length, 0);
      const firstLines = firstChunk.toString('utf8').split('\n');

      for (const line of firstLines) {
        if (!line.trim()) continue;
        try {
          const entry = JSON.parse(line);
          if (SKIP_ENTRY_TYPES.has(entry.type)) continue;
          if (entry.isSidechain) continue;
          if (entry.cwd) meta.cwd = entry.cwd;
          if (entry.timestamp) meta.createdAt = entry.timestamp;
          break;
        } catch {
          // Skip malformed
        }
      }

      const lastChunk = Buffer.alloc(64 * 1024);
      const lastPos = Math.max(0, fileSize - lastChunk.length);
      fs.readSync(fd, lastChunk, 0, lastChunk.length, lastPos);

      const lastLines = lastChunk.toString('utf8').split('\n').reverse();
      for (const line of lastLines) {
        if (!line.trim()) continue;
        try {
          const entry = JSON.parse(line);
          if (SKIP_ENTRY_TYPES.has(entry.type)) continue;
          if (entry.isSidechain) continue;

          if (entry.timestamp) {
            meta.lastMessageAt = entry.timestamp;
          }

          if (entry.type === 'assistant' && entry.message?.content) {
            const textBlock = entry.message.content.find(b => b.type === 'text');
            if (textBlock?.text) {
              meta.lastMessagePreview = textBlock.text.slice(0, 50) + (textBlock.text.length > 50 ? '...' : '');
            }
          }
          break;
        } catch {
          // Skip malformed
        }
      }
    } finally {
      fs.closeSync(fd);
    }

    // Conservative estimate so clients can "tail" without overshooting too often.
    // If this is too high, clients may request `since` beyond EOF and get no history.
    meta.messageCount = Math.max(0, Math.round(fileSize / 1500));
    return meta;
  } catch (err) {
    console.error(`[extractSessionMetaFast] Error for ${jsonlPath}:`, err.message);
    return meta;
  }
}

/**
 * Extract metadata from large files by reading just the first and last chunks
 */
async function extractMetaFromLargeFile(jsonlPath, fileSize) {
  const meta = {
    cwd: null,
    createdAt: null,
    lastMessageAt: null,
    lastMessagePreview: '',
    messageCount: 0,
  };

  // Read first 32KB for first entry
  const firstChunk = Buffer.alloc(32 * 1024);
  const fd = fs.openSync(jsonlPath, 'r');

  try {
    fs.readSync(fd, firstChunk, 0, firstChunk.length, 0);
    const firstLines = firstChunk.toString('utf8').split('\n');

    for (const line of firstLines) {
      if (!line.trim()) continue;
      try {
        const entry = JSON.parse(line);
        if (SKIP_ENTRY_TYPES.has(entry.type)) continue;
        if (entry.isSidechain) continue;

        meta.cwd = entry.cwd;
        meta.createdAt = entry.timestamp;
        break;
      } catch {
        // Skip malformed
      }
    }

    // Read last 64KB for last entry and preview
    const lastChunk = Buffer.alloc(64 * 1024);
    const lastPos = Math.max(0, fileSize - lastChunk.length);
    fs.readSync(fd, lastChunk, 0, lastChunk.length, lastPos);

    const lastLines = lastChunk.toString('utf8').split('\n').reverse();
    for (const line of lastLines) {
      if (!line.trim()) continue;
      try {
        const entry = JSON.parse(line);
        if (SKIP_ENTRY_TYPES.has(entry.type)) continue;
        if (entry.isSidechain) continue;

        meta.lastMessageAt = entry.timestamp;

        if (entry.type === 'assistant' && entry.message?.content) {
          const textBlock = entry.message.content.find(b => b.type === 'text');
          if (textBlock?.text) {
            meta.lastMessagePreview = textBlock.text.slice(0, 50) + (textBlock.text.length > 50 ? '...' : '');
          }
        }
        break;
      } catch {
        // Skip malformed
      }
    }

    // Estimate line count from file size (rough approximation)
    meta.messageCount = Math.round(fileSize / 1500); // conservative bytes/line estimate

  } finally {
    fs.closeSync(fd);
  }

  return meta;
}

/**
 * Get details for a specific session ID without scanning all sessions.
 */
async function getSessionDetails(sessionId) {
  const { jsonlPath, project, cwd } = resolveSessionPath(sessionId);
  const stat = fs.statSync(jsonlPath);
  const meta = await extractSessionMetaFast(jsonlPath, stat.size);

  return {
    id: sessionId,
    project,
    displayName: project,
    cwd: cwd || meta.cwd || `/unknown/${project}`,
    jsonlPath,
    state: isInteractiveSession(sessionId) ? 'interactive' : 'read_only',
    isActive: false,
    createdAt: meta.createdAt || stat.birthtime.toISOString(),
    lastMessageAt: meta.lastMessageAt || stat.mtime.toISOString(),
    lastMessagePreview: meta.lastMessagePreview || '',
    messageCount: meta.messageCount || 0,
    fileSize: stat.size,
  };
}

/**
 * Resolve session ID to JSONL path with security validation
 */
function resolveSessionPath(sessionId) {
  // Validate UUID format
  const uuidPattern = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/i;
  if (!uuidPattern.test(sessionId)) {
    throw new Error('INVALID_SESSION_ID');
  }

  // Search for the session in projects
  if (!fs.existsSync(CLAUDE_PROJECTS_DIR)) {
    throw new Error('SESSION_NOT_FOUND');
  }

  const projectDirs = fs.readdirSync(CLAUDE_PROJECTS_DIR, { withFileTypes: true })
    .filter(d => d.isDirectory());

  for (const projectDir of projectDirs) {
    const jsonlPath = path.join(CLAUDE_PROJECTS_DIR, projectDir.name, `${sessionId}.jsonl`);
    if (fs.existsSync(jsonlPath)) {
      // Security: verify real path is under projects dir
      const realPath = fs.realpathSync(jsonlPath);
      const realProjectsDir = fs.realpathSync(CLAUDE_PROJECTS_DIR);

      if (!realPath.startsWith(realProjectsDir)) {
        throw new Error('PATH_TRAVERSAL');
      }

      // Extract cwd from first valid entry (don't rely on slug conversion)
      let cwd = null;
      try {
        const firstChunk = Buffer.alloc(4096);
        const fd = fs.openSync(realPath, 'r');
        fs.readSync(fd, firstChunk, 0, firstChunk.length, 0);
        fs.closeSync(fd);

        const lines = firstChunk.toString('utf8').split('\n');
        for (const line of lines) {
          if (!line.trim()) continue;
          try {
            const entry = JSON.parse(line);
            if (entry.cwd && !SKIP_ENTRY_TYPES.has(entry.type)) {
              cwd = entry.cwd;
              break;
            }
          } catch {
            // Skip malformed lines
          }
        }
      } catch {
        // Fall back to display name if we can't read
      }

      return {
        jsonlPath: realPath,
        project: slugToDisplayName(projectDir.name),
        cwd: cwd || `/unknown/${slugToDisplayName(projectDir.name)}`,
      };
    }
  }

  throw new Error('SESSION_NOT_FOUND');
}

// ============================================================================
// JSONL Entry Processing
// ============================================================================

/**
 * Transform a JSONL entry into SSE events
 * Returns array of { eventType, data, cursor } objects
 */
function transformEntry(entry, lineNumber) {
  const events = [];

  // Skip internal entries
  if (SKIP_ENTRY_TYPES.has(entry.type)) {
    return events;
  }

  // Skip sidechain
  if (entry.isSidechain) {
    return events;
  }

  // Tool results (user entry with array content) should render as assistant turns
  // They're part of the assistant's "turn" in the conversation UI
  let role = entry.type;
  if (entry.type === 'user' && Array.isArray(entry.message?.content)) {
    role = 'assistant'; // tool_result entries are part of assistant turn
  }
  const messageId =
    entry.uuid ||
    entry.id ||
    entry.message?.id ||
    `${entry.sessionId || 'session'}:${lineNumber}`;

  // Determine content blocks
  let blocks = [];
  let stopReason = null;

  if (entry.type === 'user') {
    const content = entry.message?.content;
    if (typeof content === 'string') {
      // Regular user message
      blocks = [{ type: 'text', text: content }];
    } else if (Array.isArray(content)) {
      // Tool results
      blocks = content.map(b => ({
        type: 'tool_result',
        toolUseId: b.tool_use_id,
        content: typeof b.content === 'string' ? b.content : JSON.stringify(b.content),
        isError: b.is_error || false,
        charCount: (typeof b.content === 'string' ? b.content : JSON.stringify(b.content) || '').length,
      }));
    }
  } else if (entry.type === 'assistant') {
    stopReason = entry.message?.stop_reason || null;
    const content = entry.message?.content;
    if (typeof content === 'string') {
      const sanitized = sanitizeAssistantText(content);
      blocks = sanitized ? [{ type: 'text', text: sanitized }] : [];
    } else {
      blocks = (Array.isArray(content) ? content : []).map(b => {
      switch (b.type) {
        case 'text':
          return { type: 'text', text: sanitizeAssistantText(b.text) };
        case 'tool_use':
          return {
            type: 'tool_use',
            toolUseId: b.id,
            toolName: b.name,
            input: b.input,
          };
        case 'thinking':
          return { type: 'thinking', thinking: b.thinking ?? b.text ?? '' };
        default:
          return b;
      }
    });
      // Remove empty text blocks after sanitization
      blocks = blocks.filter(block => block.type !== 'text' || (block.text && String(block.text).trim().length > 0));
    }
  }

  if (blocks.length === 0) {
    return events;
  }

  // Emit message_start
  events.push({
    eventType: 'message_start',
    cursor: String(lineNumber),
    data: {
      id: messageId,
      lineNumber,
      role,
      timestamp: entry.timestamp || new Date().toISOString(),
      sessionId: entry.sessionId,
    },
  });

  // Emit content_block for each block
  blocks.forEach((block, index) => {
    events.push({
      eventType: 'content_block',
      cursor: `${lineNumber}:${index}`,
      data: {
        messageId,
        index,
        block,
      },
    });
  });

  // Emit message_end
  events.push({
    eventType: 'message_end',
    cursor: `${lineNumber}:end`,
    data: {
      id: messageId,
      stopReason,
    },
  });

  return events;
}

/**
 * Format an event as SSE wire format
 */
function formatSSE(eventType, cursor, data) {
  const lines = [];
  lines.push(`id: ${cursor}`);
  lines.push(`event: ${eventType}`);
  lines.push(`data: ${JSON.stringify(data)}`);
  lines.push('');
  lines.push('');
  return lines.join('\n');
}

// ============================================================================
// Session Tailer
// ============================================================================

/**
 * Tails a single JSONL file and broadcasts events to connected clients
 */
class SessionTailer {
  constructor(sessionId, jsonlPath, project, cwd, onIdle = null) {
    this.sessionId = sessionId;
    this.jsonlPath = jsonlPath;
    this.project = project;
    this.cwd = cwd;
    this.clients = new Set();
    this.position = 0;
    this.lineNumber = 0;
    this.watcher = null;
    this.createdAt = null;
    this.processing = false;
    this.onIdle = onIdle; // Callback when tailer becomes idle
    this.idleTimer = null;
  }

  /**
   * Start watching the file
   */
  start() {
    if (this.watcher) return;

    this.watcher = chokidar.watch(this.jsonlPath, {
      persistent: true,
      usePolling: false,
      awaitWriteFinish: {
        stabilityThreshold: 100,
        pollInterval: 50,
      },
    });

    this.watcher.on('change', () => this.processNewLines());
    this.watcher.on('error', (err) => {
      console.error(`[SessionTailer] Watch error for ${this.sessionId}:`, err.message);
    });

    console.log(`[SessionTailer] Started watching ${this.sessionId}`);
  }

  /**
   * Stop watching and cleanup
   */
  stop() {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
    if (this.watcher) {
      this.watcher.close();
      this.watcher = null;
    }
    this.clients.clear();
    console.log(`[SessionTailer] Stopped watching ${this.sessionId}`);
  }

  /**
   * Start idle timeout (called when last client disconnects)
   */
  startIdleTimeout() {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
    }
    this.idleTimer = setTimeout(() => {
      if (this.clients.size === 0 && this.onIdle) {
        console.log(`[SessionTailer] Idle timeout for ${this.sessionId}`);
        this.onIdle(this.sessionId);
      }
    }, TAILER_IDLE_TIMEOUT_MS);
  }

  /**
   * Cancel idle timeout (called when client connects)
   */
  cancelIdleTimeout() {
    if (this.idleTimer) {
      clearTimeout(this.idleTimer);
      this.idleTimer = null;
    }
  }

  /**
   * Add a client and stream history + live updates
   */
  async addClient(res, options = {}) {
    const { since = '0', limit = Infinity } = options;

    // Parse cursor: "15" or "15:2" or "15:end"
    const cursorParts = since.split(':');
    const sinceLine = parseInt(cursorParts[0], 10) || 0;
    // No block index = skip entire line (treat as "line:end")
    // "15:2" = resume after block 2, "15:end" = skip entire line
    const sinceBlock = !cursorParts[1] ? Infinity :
                       cursorParts[1] === 'end' ? Infinity :
                       parseInt(cursorParts[1], 10);

    // Stream history first (with block-level granularity)
    await this.streamHistory(res, sinceLine, sinceBlock, limit);

    // Cancel idle timeout since we have a client
    this.cancelIdleTimeout();

    // Add to live clients
    this.clients.add(res);

    // Setup cleanup on disconnect
    res.on('close', () => {
      this.clients.delete(res);
      console.log(`[SessionTailer] Client disconnected from ${this.sessionId}, ${this.clients.size} remaining`);

      // Start idle timeout if no clients remain
      if (this.clients.size === 0) {
        this.startIdleTimeout();
      }
    });

    console.log(`[SessionTailer] Client connected to ${this.sessionId}, ${this.clients.size} total`);
  }

  /**
   * Stream historical entries to a client
   * @param {Response} res - SSE response object
   * @param {number} sinceLine - Resume after this line number
   * @param {number} sinceBlock - Resume after this block index (-1 = include all blocks, Infinity = skip all)
   * @param {number} limit - Max events to emit
   */
  async streamHistory(res, sinceLine, sinceBlock, limit) {
    if (!fs.existsSync(this.jsonlPath)) return;

    // Send history_start
    res.write(formatSSE('history_start', 'history-start', { sinceLine, sinceBlock }));

    const fileStream = fs.createReadStream(this.jsonlPath);
    const rl = readline.createInterface({ input: fileStream, crlfDelay: Infinity });

    let lineNumber = 0;
    let eventCount = 0;

    for await (const line of rl) {
      lineNumber++;
      // Yield periodically so large history replays don't block the entire server.
      if (lineNumber % 200 === 0) {
        await new Promise(resolve => setImmediate(resolve));
      }

      // Skip lines before cursor
      if (lineNumber < sinceLine) continue;
      if (!line.trim()) continue;

      try {
        const entry = JSON.parse(line);
        const events = transformEntry(entry, lineNumber);

        for (const event of events) {
          if (eventCount >= limit) break;

          // For the cursor line, apply block-level filtering
          if (lineNumber === sinceLine) {
            // Parse block index from cursor (e.g., "15:2" -> block 2)
            const cursorParts = event.cursor.split(':');
            const eventBlockIndex = cursorParts[1] === 'end' ? Infinity : parseInt(cursorParts[1], 10);

            // Skip message_start (cursor "15") if we have a block filter
            if (!cursorParts[1] && sinceBlock >= 0) continue;

            // Skip blocks at or before sinceBlock
            if (eventBlockIndex !== undefined && eventBlockIndex <= sinceBlock) continue;
          }

          res.write(formatSSE(event.eventType, event.cursor, event.data));
          eventCount++;
        }

        if (eventCount >= limit) break;
      } catch {
        // Skip malformed lines
      }
    }

    // Update position tracking
    this.lineNumber = lineNumber;
    const stat = fs.statSync(this.jsonlPath);
    this.position = stat.size;

    // Extract createdAt from first entry if not set
    if (!this.createdAt && lineNumber > 0) {
      try {
        const firstLine = fs.readFileSync(this.jsonlPath, 'utf8').split('\n')[0];
        const firstEntry = JSON.parse(firstLine);
        this.createdAt = firstEntry.timestamp;
      } catch {
        this.createdAt = new Date().toISOString();
      }
    }

    // Send history_end
    res.write(formatSSE('history_end', 'history-end', { count: eventCount, totalLines: lineNumber }));
  }

  /**
   * Process new lines appended to the file
   */
  async processNewLines() {
    if (this.processing) return;
    this.processing = true;

    try {
      const stat = fs.statSync(this.jsonlPath);
      if (stat.size <= this.position) {
        this.processing = false;
        return;
      }

      const stream = fs.createReadStream(this.jsonlPath, { start: this.position });
      const rl = readline.createInterface({ input: stream, crlfDelay: Infinity });

      for await (const line of rl) {
        if (!line.trim()) continue;

        this.lineNumber++;

        try {
          const entry = JSON.parse(line);
          const events = transformEntry(entry, this.lineNumber);

          for (const event of events) {
            this.broadcast(event.eventType, event.cursor, event.data);
          }
        } catch {
          // Skip malformed lines
        }
      }

      this.position = stat.size;
    } catch (err) {
      console.error(`[SessionTailer] Error processing ${this.sessionId}:`, err.message);
    }

    this.processing = false;
  }

  /**
   * Broadcast an event to all connected clients
   */
  broadcast(eventType, cursor, data) {
    const sseData = formatSSE(eventType, cursor, data);
    for (const client of this.clients) {
      try {
        client.write(sseData);
      } catch {
        // Client disconnected
        this.clients.delete(client);
      }
    }
  }

  /**
   * Get session metadata for session_meta event
   */
  getSessionMeta() {
    let totalLines = this.lineNumber;
    try {
      const content = fs.readFileSync(this.jsonlPath, 'utf8');
      totalLines = content.split('\n').filter(l => l.trim()).length;
    } catch {
      // Use cached value
    }

    return {
      sessionId: this.sessionId,
      project: this.project,
      cwd: this.cwd,
      jsonlPath: this.jsonlPath,
      createdAt: this.createdAt || new Date().toISOString(),
      isActive: false, // Would need PTY integration
      totalLines,
    };
  }
}

// ============================================================================
// Session Tailer Manager
// ============================================================================

/**
 * Manages multiple SessionTailers (one per JSONL file)
 * Implements fan-out pattern: one watcher per file, N clients
 */
class SessionTailerManager {
  constructor() {
    this.tailers = new Map(); // sessionId -> SessionTailer
  }

  /**
   * Get or create a tailer for a session
   */
  getOrCreate(sessionId) {
    if (this.tailers.has(sessionId)) {
      return this.tailers.get(sessionId);
    }

    const { jsonlPath, project, cwd } = resolveSessionPath(sessionId);

    // Create tailer with idle callback for cleanup
    const tailer = new SessionTailer(sessionId, jsonlPath, project, cwd, (id) => {
      this.remove(id);
    });
    tailer.start();

    this.tailers.set(sessionId, tailer);
    return tailer;
  }

  /**
   * Remove a tailer (called when no clients remain after timeout)
   */
  remove(sessionId) {
    const tailer = this.tailers.get(sessionId);
    if (tailer) {
      tailer.stop();
      this.tailers.delete(sessionId);
    }
  }

  /**
   * Get stats about active tailers
   */
  getStats() {
    const stats = {
      activeTailers: this.tailers.size,
      sessions: [],
    };

    for (const [sessionId, tailer] of this.tailers) {
      stats.sessions.push({
        sessionId,
        clients: tailer.clients.size,
        lines: tailer.lineNumber,
      });
    }

    return stats;
  }
}

// ============================================================================
// Exports
// ============================================================================

module.exports = {
  SessionTailer,
  SessionTailerManager,
  discoverSessions,
  getSessionDetails,
  markInteractiveSession,
  resolveSessionPath,
  transformEntry,
  formatSSE,
  HEARTBEAT_INTERVAL_MS,
  TAILER_IDLE_TIMEOUT_MS,
};

// ============================================================================
// KNOWN LIMITATIONS
// ============================================================================
//
// PTY â†” JSONL Binding
// -------------------
// The POST /api/sessions/:id/messages endpoint writes to stdin of the PTY
// session, but there's no reliable way to correlate PTY sessions with JSONL
// files. Claude Code doesn't expose which PTY corresponds to which JSONL.
//
// Current behavior:
//   - Gateway can only send messages to sessions it started (via ptyManager)
//   - External Claude Code sessions (started in terminal) cannot receive messages
//
// Future solutions:
//   1. Claude Code could write session metadata linking PTY pid to JSONL path
//   2. Gateway could poll for JSONL file changes after PTY write
//   3. Life Chat could start its own Claude Code sessions with known mappings
//
// For now, the Swift app should treat existing sessions as read-only and
// start new sessions through the gateway for interactive use.
